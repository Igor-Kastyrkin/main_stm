

/*

unsigned strlen1(const char *str)
{
  unsigned cnt = 0;
  while (((short)(*(str + cnt)) >= 0x20)) ++cnt;
  return cnt;
}

*/



/*



  byte fStepFf(leedLeg leedLgOgj, short angle)
  {
  posOfMotors mot; // для совместимости
  rot_dir dir;
  leedLeg leed_leg1 = leedLgOgj;
  //  mot.rbOrient += angle;
  fOtladkaMes("Angle=" + String(angle));
  if (angle < 0)
  {
    dir =  leftA;
    fOtladkaMes("dir=LEFT");
  }
  if (angle > 0)
  {
    dir = rightA;
    fOtladkaMes("dir=RIGHT");
  }
  if (angle == 0)
  {
    fErrorMes("AngleIsNull");
    return 1;
  }
  // Стоим на обоих ногах?
  if (fstandStill(mot))
  {
    pr_telega.fDoezd(*motorLink, telega); // телега доезжает если необходимо
    if (leed_leg1 == leftLeed)   // левая нога впереди?
    {
      if (moveMassLeft(mot)) return 1; // ехать влево
      // поднимаем(втягиваем) правую ногу.
      if (Leg_fn(right_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
      // поворачиваемся на левой ноге
      //      if (orient_steps(left_leg, forward, mot) && (stWork == StWork)) return 1;
      change_orient(dir, mot, abs(angle));
      if (fBreak(not_leg, foot, mot))
      {
        return 1;
      }
      // опускаем правую ногу
      if (Leg_fn(right_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
      // перевозим тележку вправо
      //      if (moveMassRight(mot)) return 1; // ехать вправо
    }
    if (leed_leg1 == rightLeed)
    {
      // поднимаем(втягиваем) левую ногу.
      if (moveMassRight(mot)) return 1; // ехать вправо
      if (Leg_fn(left_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
      // поворачиваемся на правой ноге
      //      if (orient_steps(right_leg, forward, mot) && (stWork == StWork)) return 1;
      change_orient(dir, mot, abs(angle));
      if (fBreak(not_leg, foot, mot))
      {
        return 1;
      }
      // опускаем левую ногу
      if (Leg_fn(left_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
      // перевозим тележку вправо
      //     if (moveMassLeft(mot)) return 1; // ехать влево
    }
  }
  return 0;
  }











  byte fStepBk(leedLeg leedLgOgj, short angle)
  {
  posOfMotors mot; // для совместимости
  rot_dir dir;
  leedLeg leed_leg1 = leedLgOgj;
  //  mot.rbOrient += angle;
  if (angle < 0) dir =  leftA;
  if (angle > 0) dir = rightA;

  if (fstandStill(mot))
  {
    pr_telega.fDoezd(*motorLink, telega);
    if (leed_leg1 == leftLeed)
    {
      if (moveMassRight(mot)) return 1; // ехать вправо
      // поднимаем(втягиваем) левую ногу.
      if (Leg_fn(left_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
      // поворачиваемся на правой ноге
      //      if (orient_steps(right_leg, backward, mot) && (stWork == StWork)) return 1;
      change_orient(dir, mot, abs(angle));
      if (fBreak(not_leg, foot, mot))
      {
        return 1;
      }
      // опускаем левую ногу
      if (Leg_fn(left_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
      // перевозим тележку вправо
      //      if (moveMassLeft(mot)) return 1; // ехать влево
    }
    if (leed_leg1 == rightLeed)
    {
      if (moveMassLeft(mot)) return 1; // ехать влево
      // поднимаем(втягиваем) правую ногу.
      if (Leg_fn(right_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
      // поворачиваемся на левой ноге
      //      if (orient_steps(left_leg, backward, mot) && (stWork == StWork)) return 1;
      change_orient(dir, mot, abs(angle));
      if (fBreak(not_leg, foot, mot))
      {
        return 1;
      }
      // опускаем правую ногу
      if (Leg_fn(right_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
      // перевозим тележку вправо
      //    if (moveMassRight(mot)) return 1; // ехать вправо
    }
    if (leed_leg1 == noLeed)
    {
      fOtladkaMes("NoLeed");
    }
  }
  else
  {
    fOtladkaMes("PlsStandStill");
  }
  return 0;
  }


*/





/*

bool fShakeHand(const byte shakeCnt, posOfMotors & mot)
{

  seetUpDown(mot, 1); // привстаем
  //  if(Leg_fn(robot_leg leg, mode, leg_dir dir, posOfMotors & mot))

  for (int i = 0; i < shakeCnt; i++)
  {
    if (fBreak(right_leg, foot, mot)) break;
	mot.MoveRightLegCurrentSteps(- stepsPerLegRot * fullRotationLimit,BTANYTb_CH);
//    mot.RightLegCurrentSteps = - stepsPerLegRot * fullRotationLimit;
//    SerR.prepareMessage( 'h', mot.RightLegCurrentSteps); // вытягиваем
    if (fAnswerWait(right_leg, knee, mot)) break;

//    mot.RightLegCurrentSteps = 0L;
    mot.MoveRightLegCurrentSteps(0L, BbITANYTb_CH);
//    SerR.prepareMessage( 'i', mot.RightLegCurrentSteps); // втягиваем
    if (fAnswerWait(right_leg, knee, mot)) break;
  }
  return 0;
}
*/





/*
// поставить обе ноги на верхнюю ступеньку
byte stepsTogether(              step_dir dir,
                                 posOfMotors & mot,
                                 const long zapas_na_povorot,
								 robot_leg legRot,
								 robot_leg legUp,
								 robot_leg legDn,
							     long raznost_v_polozhenii,
                                 byte BbIcoTa_CTYnEHbKU,
								 long leg_up_for_rotate								 
)
{
  // 1. Передвинуть телегу на другую ногу
  // 2. Вытянуть опорную ногу и втянуть другую на 30 мм от концевика
  // 3. повернуться до 0
  // 4. Опустить ногу так, чтобы обе были на поверхности.
    if(abs(raznost_v_polozhenii) == stepDephCalc(BbIcoTa_CTYnEHbKU))
    {
   //   calcLegForStep(raznost_v_polozhenii, legRot, legUp, legDn);
//  1.2.2 перевозим тележку
  //  если нужно поднять левую ногу, то телегу двиаем вправо
      if(legUp == left_leg) if (pr_telega.RotateStpsOnly(*motorLink, telega, pr_telega.DriveRight())) return 1;
  //  если нужно поднять правую ногу, то телегу двиаем влево
      if(legUp == right_leg) if (pr_telega.RotateStpsOnly(*motorLink, telega, pr_telega.DriveLeft())) return 1;
  	// Вытягиваем одну ногу на которой тележка до конца
  	// Вытягиваем одну ногу на которой тележка до конца
      if (Leg_pfn(legDn, energySaving, vytianut, mot) && (stWork == StWork)) return 1;
      delay(pauseForSerial);
	// Втягиваем противоположную ногу на заданное положение
      if (Leg_pfn(legUp, energySaving, vtianut, mot, stepDephCalc(leg_up_for_rotate)) && (stWork == StWork)) return 1;
    // поворачиваемся на 90	
      if (orient_steps(0, legRot, dir, mot) && (stWork == StWork)) return 1;
  // 4. Опускаем ногу на ступеньку
 // опускаем ногу на 30 мм
      //if (LegToPos(legUp, vytianut, mot, stepDephCalc(zapas_na_povorot)) && (stWork == StWork)) return 1;
	  
    }
//  orient_steps(0, leg, dir, mot);
//  StepsManage(mot, energySaving);
  return 0;
}



// выбрать ногу, которую следует поднять на следующюю ступеньку.
void calcLegForStep(long raznica_v_polozhenii, robot_leg &OutLegRot, robot_leg &OutLegUp, robot_leg &OutLegDn)
{

  —————
  |	  |
  –   |
	  |
      -
 
  if(raznica_v_polozhenii < 0)
  {
    OutLegRot = right_leg; // будем поворачиватся на right_leg
	OutLegUp  = left_leg;
	OutLegDn  = right_leg;
  }

  T————
  |	  |
  |   –
  |
  –
 
  if(raznica_v_polozhenii > 0)
  {
    OutLegRot =  left_leg; // будем поворачиватся на left_leg
	OutLegUp  =  right_leg;
	OutLegDn  =  left_leg;
  }
}

*/





// 0=левый 1=правый.
/*
  short readAnswerletter(const bool L_Or_R, const char letter)
  {
  short returnValue;
  int k = 0;
  char cmdL = 0x0, cmdR = 0x0;
  const short delay_nrf_pause = 10;
  unsigned long last_time = millis();
  unsigned long return_time = 60000;  // отсрочка 60 секунд
  long Data1L, Data1R;
  long oldFootData1L = mot.LeftFootCurrentSteps, oldFootData1R = mot.RightFootCurrentSteps;
  long oldKneeData1L = mot.LeftLegCurrentSteps, oldKneeData1R = mot.RightLegCurrentSteps;
  if(L_Or_R == 0)
  {
    while (cmdL != letter)
    { // ждем ответ от колена
    //        if (fBreak(left_leg, knee))  return 1;
      if ((k % 100) == 0) //остаток от деления равен нулю?
      //		  fOtladkaMes(".");
         k++;
      delay(delay_nrf_pause);
      if (SerL.handle_serial() > 0) // что-то принято?
      {
        SerL.getString1(cmdL, Data1L); // читаем что принято
        if (cmdL == letter)
        {
          // проверяем положение колена
          //     fOtladkaMes("LKnee:" + String(Data1L));
          if (mot.LeftLegCurrentSteps != Data1L)
          {
  //           fErrorMes("MUST BE:" + String(mot.LeftLegCurrentSteps));
            delay(2000);
            mot.LeftLegCurrentSteps = Data1L;
			returnValue = 1;
          }
        }
        else
        {
  //         String errStr = "LftAswrKneeIs:" + String(cmdL);
  //         fErrorMes(errStr);
  //        delay(2000);
		  returnValue = 2;
        }
      }
      if (last_time + return_time < millis())
      {
 		returnValue = 3;
  //       fErrorMes("LEFT-KNEE-TIME-ERROR");
        mot.LeftLegCurrentSteps = oldKneeData1L;
  #ifdef STOP_ON_ERROR
        cmdL = cmdR = 0;
        return returnValue;
  #endif
        break;
      }
      pr_telega.fDoezd(*motorLink, telega);
    }
  }
  return returnValue;
  }
*/







// ----- ОРИЕНТИРОВАНИЕ В НУЖНОМ НАПРАВЛЕНИИ -----
/*
  bool change_orient(rot_dir dir, posOfMotors & mot, float min_stp)
  {
  fOtladkaMes("min_stp:" + String(min_stp));
  short add_data = min_stp;
  min_stp = min_stp * 444.444444;
  if (readyForRotLeftFoot(mot))  // стоим на правой ноге?
  {
    if (dir == leftA) // поворот влево?
    { // поворачиваемся в заданное положение + текущее положение.
      fOtladkaMes("RotRghtDirLft");
      mot.RightFootCurrentSteps = mot.rbOrient * 160000L / 360L - min_stp;
      SerR.prepareMessage( 'c', mot.RightFootCurrentSteps);
      fOtladkaMes("TurnLeftR:" + String(mot.RightFootCurrentSteps));
      mot.rbOrient -= add_data;  //????
      // отворачиваем противоположную стопу в обратную сторону
      mot.LeftFootCurrentSteps = -mot.rbOrient * 160000L / 360L + min_stp;
      SerL.prepareMessage( 'c', mot.LeftFootCurrentSteps);
      delay(100);
      fOtladkaMes("TurnLeftL:" + String(mot.LeftFootCurrentSteps));
      if (fAnswerWait(all_legs,  foot, mot))
      {
        leed_leg = rightLeed;
        return 1; //ждем
      }
    }
    if (dir == rightA)
    {
      fOtladkaMes("RotRghtDirRight");
      mot.RightFootCurrentSteps = mot.rbOrient * 160000L / 360L + min_stp;
      SerR.prepareMessage( 'c', mot.RightFootCurrentSteps);
      fOtladkaMes("TurnRightR:" + String(mot.RightFootCurrentSteps));
      mot.rbOrient += add_data;   //???
      // отворачиваем противоположную стопу в обратную сторону
      mot.LeftFootCurrentSteps = -mot.rbOrient * 160000L / 360L - min_stp;
      SerL.prepareMessage( 'c', mot.LeftFootCurrentSteps);
      delay(100);
      fOtladkaMes("TurnRightL:" + String(mot.LeftFootCurrentSteps));
      if (fAnswerWait(all_legs,  foot, mot))
      {
        leed_leg = leftLeed;
        return 1; //ждем
      }
    }
  }
  else if (readyForRotLeftFoot(mot))  // стоим на левой ноге?
  {
    //    fOtladkaMes("RghtTrnng\r\n");
    if (dir == leftA)
    {
      fOtladkaMes("RotLftDirLft");
      mot.LeftFootCurrentSteps = -mot.rbOrient * 160000L / 360L + min_stp;
      SerL.prepareMessage( 'c', mot.LeftFootCurrentSteps);
      fOtladkaMes("TurnLeftL:" + String(mot.LeftFootCurrentSteps));
      mot.rbOrient -= add_data;
      // отворачиваем противоположную стопу в обратную сторону
      mot.RightFootCurrentSteps = mot.rbOrient * 160000L / 360L - min_stp;
      SerR.prepareMessage( 'c', mot.RightFootCurrentSteps);
      delay(100);
      fOtladkaMes("TurnLeftR:" + String(mot.RightFootCurrentSteps));
      if (fAnswerWait(all_legs,  foot, mot))
      {
        leed_leg = rightLeed;
        return 1; //ждем
      }
    }
    if (dir == rightA)
    {
      fOtladkaMes("RotLftDirRght");
      mot.LeftFootCurrentSteps = -mot.rbOrient * 160000L / 360L - min_stp;
      SerL.prepareMessage( 'c', mot.LeftFootCurrentSteps);
      fOtladkaMes("TurnRightL:" + String(mot.LeftFootCurrentSteps));
      mot.rbOrient += add_data;
      // отворачиваем противоположную стопу в обратную сторону
      mot.RightFootCurrentSteps = mot.rbOrient * 160000L / 360L + min_stp;
      SerR.prepareMessage( 'c', mot.RightFootCurrentSteps);
      fOtladkaMes("TurnRightR:" + String(mot.RightFootCurrentSteps));
      if (fAnswerWait(all_legs,  foot, mot))
      {
        leed_leg = leftLeed;
        return 1; //ждем
      }
    }
  }
  else if ((mot.RightLegCurrentSteps - mot.LeftLegCurrentSteps > -mot.stepsDepthInSteps) && (mot.RightLegCurrentSteps - mot.LeftLegCurrentSteps < mot.stepsDepthInSteps)) // стоим на обеих ногах?
  {
    fErrorMes("BothLegsOnTheSirfaceError");
    return 1;
  }
  //  fOtladkaMes("ChngeOrientSuccess\r\n");
  return 0;
  }// Change_Orient
*/







/*
//    -------	ПОВОРОТЫ С ДОШАГИВАНИЕМ  -------

//   posOfMotors & mot,  структура с исходными данными двигателей
//  short minStep,       угол маленькие шашки, для полного поворота
//    short newOrient)    на какой итоговый угол нужно повернуться относительно текущего положения
byte rotPlace(posOfMotors & mot, short minStep, short newOrient, regimRaboty &mode)
{
  // если текущее положение равно новому,  то нужно выйти
  
    if(mot.GetOrient() == (newOrient))
    {
      fErrorMes("SAME_ORIENT");
  	return 0;
    }
  */
  /*
  //   неважно в какую сторону должен пытаться идти робот
  fOtladkaMes("AbsUgolDo=" + String(mot.GetOrient()));
  short old_Orient = mot.GetOrient();    // запоминаем прежнее значение ориентации
  // защита от противоположного направления шажков от основного направления поворота
  if (newOrient < 0) // если новое значение угла меньше нуля
  {
    minStep = - abs(minStep);
  }
  else
  {
    minStep = abs(minStep); //
  }

  step_dir dir;
  if (oldActions == walkFf) dir = backward;
  if (oldActions == walkBk) dir = forward;
  if ((oldActions != walkFf) && (oldActions != walkBk)) dir = unknown;
  if (pr_telega.dir_flg  ==  middle);
  // цикл пробегает все значения с шагом минимального угла и заканчивается
  // когда остается сделать шаг, меньше минимального заданного значения шага.
  short i = 0;
  short lastPreposition = newOrient - minStep;

  // сперва нужно встать в ноль, если планируется движение не в ту сторону,
  // куда смотрим сейчас

  // проверяем чтоб не делать лишних движений
  if (mot.GetLeftFootCurrentSteps() != -mot.GetRightFootCurrentSteps())
  {
    if (readyForRotRightFoot(mot))  // стоим на правой ноге
    {
      //левая нога впереди(смотрим влево)?
      if (fEastOrWestStandingCalc(mot) == 0)
      {
        // нужно повернуться вправо?
        if (newOrient < 0)
        { // поворачиваемся в исходное положение
          fOtladkaMes("L+|**<|&>");
          if (orient_steps(0, right_leg, backward, mot) && (stWork == StWork)) return 1;
          // опускаем левую ногу (будем стоять на обоих)
          if (Leg_fn(left_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
          // главное потом этой же ногой не сделать движение
          // для этого нужно перевезти тележку и в следующей функции
          // проверить положение тележки, при этом в следующей функции
          // нужно проверять, что тележка не в центре
          if (moveMassLeft(mot)) return 1;
        }
      }// fEastOrWestStandingCalc
      // левая нога не впереди
      else
      {
        // нужно повернуться влево?
        if (newOrient > 0)
        {
          fOtladkaMes("L+|**>|&<");
          if (orient_steps(0, right_leg, forward, mot) && (stWork == StWork)) return 1;
          // опускаем левую ногу (будем стоять на обоих)
          if (Leg_fn(left_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
          // главное потом этой же ногой не сделать движение
          // для этого нужно перевезти тележку и в следующей функции
          // проверить положение тележки, при этом в следующей функции
          // нужно проверять, что тележка не в центре
          if (moveMassLeft(mot)) return 1;
        }
      }
    }
    else if (readyForRotLeftFoot(mot)) // стоим на левой ноге
    {
      // правая нога впереди(смотрим вправо)?
      if (fEastOrWestStandingCalc(mot) == 1)
      {
        // нужно повернуться влево?
        if (newOrient > 0)
        {
          fOtladkaMes("R+|**>|&<");
          // поворачиваемся в исходное положение
          if (orient_steps(0, left_leg, backward, mot) && (stWork == StWork)) return 1;
          // опускаем правую. ногу (будем стоять на обоих)
          if (Leg_fn(right_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
          // главное потом этой же ногой не сделать движение
          // для этого нужно перевезти тележку и в следующей функции
          // проверить положение тележки, при этом в следующей функции
          // нужно проверять, что тележка не в центре
          if (moveMassRight(mot)) return 1;
        }
      }
      else
      {
        // нужно повернуться вправо?
        if (newOrient < 0)
        {
          fOtladkaMes("R+|**<|&>");
          if (orient_steps(0, left_leg, forward, mot) && (stWork == StWork)) return 1;
          // опускаем правую. ногу (будем стоять на обоих)
          if (Leg_fn(right_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
          // главное потом этой же ногой не сделать движение
          // для этого нужно перевезти тележку и в следующей функции
          // проверить положение тележки, при этом в следующей функции
          // нужно проверять, что тележка не в центре
          if (moveMassRight(mot)) return 1;
        }
      }
    }
    else if (fstandStill(mot))
    {
      //левая нога впереди(смотрим влево)?
      if (fEastOrWestStandingCalc(mot) == 0)
      {
        // нужно повернуться вправо?
        if (newOrient < 0)
        {
          if (moveMassRight(mot)) return 1;
          if (Leg_fn(left_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
          if (orient_steps(0, right_leg, backward, mot) && (stWork == StWork)) return 1;
          if (Leg_fn(left_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
          if (moveMassLeft(mot)) return 1;
          fOtladkaMes("SS|**<|&>");
        }
      }
      else
      {
        if (newOrient > 0)
        {
          if (moveMassLeft(mot)) return 1;
          if (Leg_fn(right_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
          if (orient_steps(0, left_leg, backward, mot) && (stWork == StWork)) return 1;
          if (Leg_fn(right_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
          if (moveMassRight(mot)) return 1;
          fOtladkaMes("SS|**>|&<");
        }
      }
    }
    // когда нужно повернуться из других положений, эту функцию выполняет код далее
    fOtladkaMes("1end");
  }


  // если одна нога повернута сильнее, чем нужно повернуть в этой функции то цикл for пропускаем.
  if ((abs(lastPreposition) + abs(mot.GetOrient())) < abs(mot.LeftFootCurrentSteps / (angleToStep(1L) * 2)))
  {
    fOtladkaMes("GetOrient():" + String(mot.GetOrient()));
    fOtladkaMes("lstPrepsition:" + String(lastPreposition));
    //    fOtladkaMes("lastPreposition:" + String(lastPreposition));
    fOtladkaMes("LFCurntStps:" + String(mot.LeftFootCurrentSteps / (angleToStep(1L) * 2)));
    fOtladkaMes(String(abs(lastPreposition)) + "<" + String(abs(mot.LeftFootCurrentSteps / (angleToStep(1L) * 2)) - abs(2 * mot.GetOrient())));

    lastPreposition = 0;
  }
  if (abs(lastPreposition) < abs(i))  fOtladkaMes("2 step");

  for (i = 0; abs(lastPreposition) > abs(i); i += minStep)
  {
    // в зависимости от того, на какой ноге изначально стоим, выполняем действие
    // которое в итоге заканчивается новым положением. Если стоял на правой ноге
    // новое положение будет стойка на левой ноге
    mot.OrientInc(minStep);  		 // ориентируем понемногу
    fOtladkaMes("GetOrient()=" + String(mot.GetOrient()));
    if (readyForRotRightFoot(mot))  // стоим на правой ноге
    {
      // поворачиваемся вперед на правой ноге на нужный угол
      if (orient_steps(0, right_leg, dir, mot) && (stWork == StWork)) return 1;
      //	  change_orient(turn_dir, mot, minStep);
      // опускаем левую ногу (будем стоять на обоих)
      if (Leg_fn(left_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
      // перевозим тележку влево
      if (moveMassLeft(mot)) return 1;
      // поднимаем(втягиваем) правую ногу.
      if (Leg_fn(right_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
    } else if (readyForRotLeftFoot(mot)) // стоим на левой ноге
    {
      // поворачиваемся на левой ноге
      if (orient_steps(0, left_leg, dir, mot) && (stWork == StWork)) return 1;
      //	  change_orient(turn_dir, mot, minStep);
      // опускаем правую ногу
      if (Leg_fn(right_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
      // перевозим тележку вправо
      if (moveMassRight(mot)) return 1; // ехать вправо
      // поднимаем левую ногу
      if (Leg_fn(left_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
    } else if (fstandStill(mot))  // стоим на обоих ногах
    {
      // если условно правая нога впереди(которая левая на самом деле)
      // если шли вперед
      // если newOrient больше 0
      // тогда тележку влево
      // тогда поворачиваемся вправо
      // иначе
      //
      if (pr_telega.dir_flg  ==  right)  {
        // поднимаем(втягиваем) левую ногу.
        if (Leg_fn(left_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
        // поворачиваемся вперед на правой ноге на нужный угол
        if (orient_steps(0, right_leg, dir, mot) && (stWork == StWork)) return 1;
        // опускаем левую ногу (будем стоять на обоих)
        if (Leg_fn(left_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
        //         if (fBreak(left_leg, knee)) break;
        if (moveMassLeft(mot)) return 1; // ехать влево
        fOtladkaMes("SS|&^");
      } else if (pr_telega.dir_flg  ==  left)
      {
        // поднимаем(втягиваем) правую ногу.
        if (Leg_fn(right_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
        // поворачиваемся на левой ноге
        if (orient_steps(0, left_leg, dir, mot) && (stWork == StWork)) return 1;
        //	    change_orient(turn_dir, mot, minStep);
        // опускаем правую ногу
        if (Leg_fn(right_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
        if (moveMassRight(mot)) return 1; // ехать вправо
        fOtladkaMes("SS|&^");
      }
      else if (pr_telega.dir_flg  ==  middle)
      {
        if (moveMassLeft(mot)) return 1; // ехать влево
        // поднимаем(втягиваем) правую ногу.
        if (Leg_fn(right_leg, mode, vtianut, mot) && (stWork == StWork)) return 1;
        // поворачиваемся на левой ноге
        if (orient_steps(0, left_leg, dir, mot) && (stWork == StWork)) return 1;
        //	    change_orient(turn_dir, mot, minStep);
        // опускаем правую ногу
        if (Leg_fn(right_leg, mode, vytianut, mot) && (stWork == StWork)) return 1;
        if (moveMassRight(mot)) return 1; // ехать вправо
        fOtladkaMes("SS|&^");
      }
    }
    fOtladkaMes("2run");
  }
  // условие когда осталось доделать последний шаг для завершения поворота

  if (mot.GetOrient() != (old_Orient + newOrient))
  {
    fOtladkaMes("3start");
    // известно, что итоговый угол это сложение первоначального угла перед работой функции
    // и угла на который нужно в итоге повернуться
    mot.SetOrient((long)old_Orient + newOrient);

    if (readyForRotRightFoot(mot))  // стоим на правой ноге
    {
      // поворачиваемся вперед на правой ноге на нужный угол
      if (orient_steps(0, right_leg, dir, mot)) return 1;
      // опускаем левую ногу (будем стоять на обоих)
      if (Leg_fn(left_leg, mode, vytianut, mot)) return 1;
      // перевозим тележку влево
      if (moveMassLeft(mot)) return 1;
      // поднимаем(втягиваем) правую ногу.
      if (Leg_fn(right_leg, mode, vtianut, mot)) return 1;
    } else if (readyForRotLeftFoot(mot)) // стоим на левой ноге
    {
      // поворачиваемся на левой ноге
      if (orient_steps(0, left_leg, dir, mot)) return 1;
      // 	  change_orient(turn_dir, mot, old_Orient + newOrient - mot.rbOrient);
      // опускаем правую ногу
      if (Leg_fn(right_leg, mode, vytianut, mot)) return 1;
      // перевозим тележку вправо
      if (moveMassRight(mot)) return 1; // ехать вправо
      // поднимаем левую ногу
      if (Leg_fn(left_leg, mode, vtianut, mot)) return 1;
    } else if (fstandStill(mot))  // стоим на обоих ногах
    {
      if (pr_telega.dir_flg  ==  right)  {
        // поднимаем(втягиваем) левую ногу.
        if (Leg_fn(left_leg, mode, vtianut, mot)) return 1;
        // поворачиваемся вперед на правой ноге на нужный угол
        if (orient_steps(0, right_leg, dir, mot)) return 1;
        // 	    change_orient(turn_dir, mot, old_Orient + newOrient - mot.rbOrient);
        // опускаем левую ногу (будем стоять на обоих)
        if (Leg_fn(left_leg, mode, vytianut, mot)) return 1;
        //         if (fBreak(left_leg, knee)) break;
        if (moveMassLeft(mot)) return 1; // ехать влево
      } else if (pr_telega.dir_flg  ==  left)
      {
        // поднимаем(втягиваем) правую ногу.
        if (Leg_fn(right_leg, mode, vtianut, mot)) return 1;
        // поворачиваемся на левой ноге
        if (orient_steps(0, left_leg, dir, mot)) return 1;
        // 	    change_orient(turn_dir, mot, old_Orient + newOrient - mot.rbOrient);
        // опускаем правую ногу
        if (Leg_fn(right_leg, mode, vytianut, mot)) return 1;
        if (moveMassRight(mot)) return 1; // ехать вправо
      }
      else if (pr_telega.dir_flg  ==  middle)
      {
        if (dir == forward) {
          //левая нога впереди(смотрим влево)?
          if (fEastOrWestStandingCalc(mot) == 0)
          {
            if (moveMassLeft(mot)) return 1; // ехать влево
            // поднимаем(втягиваем) левую ногу.
            if (Leg_fn(right_leg, mode, vtianut, mot)) return 1;
            // поворачиваемся вперед на правой ноге на нужный угол
            if (orient_steps(0, left_leg, forward, mot)) return 1;
            // опускаем левую ногу (будем стоять на обоих)
            if (Leg_fn(right_leg, mode, vytianut, mot)) return 1;
            //         if (fBreak(left_leg, knee)) break;
            //        if(moveMassLeft(mot)) return 1; // ехать влево
          }	//правая нога впереди(смотрим вправо)?
          else if (fEastOrWestStandingCalc(mot) == 1)
          {
            if (moveMassRight(mot)) return 1; // ехать влево
            // поднимаем(втягиваем) правую ногу.
            if (Leg_fn(left_leg, mode, vtianut, mot)) return 1;
            // поворачиваемся вперед на правой ноге на нужный угол
            if (orient_steps(0, right_leg, forward, mot)) return 1;
            // опускаем левую ногу (будем стоять на обоих)
            if (Leg_fn(left_leg, mode, vytianut, mot)) return 1;
          }
        } else if (dir == backward)
        {
          //левая нога впереди(смотрим влево)?
          if (fEastOrWestStandingCalc(mot) == 0)
          {
            if (moveMassRight(mot)) return 1;
            // поднимаем(втягиваем) левую ногу.
            if (Leg_fn(left_leg, mode, vtianut, mot)) return 1;
            // поворачиваемся вперед на правой ноге на нужный угол
            if (orient_steps(0, right_leg, backward, mot)) return 1;
            // опускаем левую ногу (будем стоять на обоих)
            if (Leg_fn(left_leg, mode, vytianut, mot)) return 1;
            //         if (fBreak(left_leg, knee)) break;
            //        if(moveMassLeft(mot)) return 1; // ехать влево
          }	//правая нога впереди(смотрим вправо)?
          else if (fEastOrWestStandingCalc(mot) == 1)
          {
            if (moveMassLeft(mot)) return 1; // ехать влево
            // поднимаем(втягиваем) правую ногу.
            if (Leg_fn(right_leg, mode, vtianut, mot)) return 1;
            // поворачиваемся вперед на правой ноге на нужный угол
            if (orient_steps(0, left_leg, backward, mot)) return 1;
            // опускаем левую ногу (будем стоять на обоих)
            if (Leg_fn(right_leg, mode, vytianut, mot)) return 1;

          }
        }
      }
    }
    fOtladkaMes("3end");
  }
  fOtladkaMes("AbsUgolPosle=" + String(mot.GetOrient()));
  //  stepAngle = oldStepAngle;  // восстанавливаем угол хождения для правильного шагания в будущем
  return 0;
}


byte fTurnAngle(short angle)
{
  return 0;
}


*/






byte LegRightMoveTo(posOfMotors & mot, long LegPos, char BTAHYTb)
{
  if(mot.GetCurrentZero()!=0){
    fErrorMes("LegRMoveTo: CurrZer!=0");
    return 1;
  }
  int out = 0;
  mot.MoveRightLegCurrentSteps(LegPos, BTAHYTb);
  if (fAnswerWait(right_leg,  knee, mot, 'T', BTAHYTb)) out = 1; //ждем
  return out;
}






// 0 < pos < 100 в процентах от допусимого положения
bool moveLegToPos(robot_leg leg, short pos, posOfMotors & mot)
{
  //  bool ft = 0;
  /* Проверяем, чтоб нога, которую будем двигать,
    не находилась выше той, на которой стоим */
  if ((leg == right_leg) && (readyForRotLeftFoot(mot) || fstandStill(mot)))
  {
    //    ft = 1;
    // перевозим тележку на опорную ногу
    if (moveMassLeft(mot)) return 1;
    // проверяем, чтоб нога не двигалась за пределеы отведенной области
    // отведенная область это область от равного положения ног
    // до максимальной возможной втянутости
    long range = (mot.GetLeftLegCurrentSteps() - stepsPerLegRot * fullRotationLimit);
    int pol = range * pos / 100;
    int sol = mot.GetLeftLegCurrentSteps() + pol;
    if (sol < mot.GetRightLegCurrentSteps())
    {
      mot.MoveRightLegCurrentSteps(sol,BTANYTb_CH);
//      SerR.prepareMessage( 'h', mot.RightLegCurrentSteps); // вытягиваем
      if (fAnswerWait(right_leg, knee, mot)) return 1;
    } else
    {
      mot.MoveRightLegCurrentSteps(sol, BbITANYTb_CH);
 //     SerR.prepareMessage( 'i', mot.RightLegCurrentSteps); // втягиваем
      if (fAnswerWait(right_leg, knee, mot)) return 1;
    }
  }

  if ((leg == left_leg) && (readyForRotLeftFoot(mot) || fstandStill(mot)))
  {
    //   ft = 1;
    // перевозим тележку на опорную ногу
    if (moveMassRight(mot)) return 1;
    // проверяем, чтоб нога не двигалась за пределеы отведенной области
    // отведенная область это область от равного положения ног
    // до максимальной возможной втянутости
    long range = (mot.GetRightLegCurrentSteps() - stepsPerLegRot * fullRotationLimit);
    int pol = range * pos / 100;
    int sol = mot.GetRightLegCurrentSteps() + pol;
    if (sol < mot.GetLeftLegCurrentSteps())
    {
      mot.MoveLeftLegCurrentSteps(sol, BTANYTb_CH);
//      SerL.prepareMessage( 'h', mot.GetLeftLegCurrentSteps()); // вытягиваем
      if (fAnswerWait(right_leg, knee, mot)) return 1;
    } else
    {
      mot.MoveRightLegCurrentSteps(sol, BbITANYTb_CH);
//      SerR.prepareMessage( 'i', mot.RightLegCurrentSteps); // втягиваем
      if (fAnswerWait(right_leg, knee, mot)) return 1;
    }
  }
  return 0;
}





/*
byte fMinStp(posOfMotors & mot, unsigned short minStep, regimRaboty &mode)
{
  fErrorMes("Small angle");
  return 1;
}
*/

